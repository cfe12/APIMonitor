using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using EasyHook;
using System.Runtime.InteropServices;

namespace MalMonInject
{
    public class ProcActivities:ActivityMonitor
    {
        LocalHook CreateProcessHook;

        public ProcActivities(MalMonInject Inject) : base(Inject) { }
        public override void InstallHook()
        {
            CreateProcessHook = LocalHook.Create(
                        LocalHook.GetProcAddress("kernel32.dll", "CreateProcessW"),
                        new DCreateProcessW(CreateProcessW_Hooked),
                        this.Injector);
            CreateProcessHook.ThreadACL.SetExclusiveACL(new Int32[] { 0 });

        }

        /*----code generated by script CodeGenerator.py----*/
        /*----CreateProcessW----*/
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public struct STARTUPINFOW
        {

            /// DWORD->unsigned int
            public uint cb;

            /// LPWSTR->WCHAR*
            [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.LPWStr)]
            public string lpReserved;

            /// LPWSTR->WCHAR*
            [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.LPWStr)]
            public string lpDesktop;

            /// LPWSTR->WCHAR*
            [System.Runtime.InteropServices.MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType.LPWStr)]
            public string lpTitle;

            /// DWORD->unsigned int
            public uint dwX;

            /// DWORD->unsigned int
            public uint dwY;

            /// DWORD->unsigned int
            public uint dwXSize;

            /// DWORD->unsigned int
            public uint dwYSize;

            /// DWORD->unsigned int
            public uint dwXCountChars;

            /// DWORD->unsigned int
            public uint dwYCountChars;

            /// DWORD->unsigned int
            public uint dwFillAttribute;

            /// DWORD->unsigned int
            public uint dwFlags;

            /// WORD->unsigned short
            public ushort wShowWindow;

            /// WORD->unsigned short
            public ushort cbReserved2;

            /// LPBYTE->BYTE*
            public System.IntPtr lpReserved2;

            /// HANDLE->void*
            public System.IntPtr hStdInput;

            /// HANDLE->void*
            public System.IntPtr hStdOutput;

            /// HANDLE->void*
            public System.IntPtr hStdError;
        }
        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {

            /// HANDLE->void*
            public System.IntPtr hProcess;

            /// HANDLE->void*
            public System.IntPtr hThread;

            /// DWORD->unsigned int
            public uint dwProcessId;

            /// DWORD->unsigned int
            public uint dwThreadId;
        }

        [UnmanagedFunctionPointer(CallingConvention.StdCall, CharSet = CharSet.Unicode, SetLastError = true)]
        delegate bool DCreateProcessW([MarshalAsAttribute(UnmanagedType.LPWStr)] string lpApplicationName, IntPtr lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, [MarshalAsAttribute(UnmanagedType.Bool)] bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, [MarshalAsAttribute(UnmanagedType.LPWStr)] string lpCurrentDirectory, ref STARTUPINFOW lpStartupInfo, [OutAttribute()] out PROCESS_INFORMATION lpProcessInformation);
        [DllImportAttribute("kernel32.dll", EntryPoint = "CreateProcessW")]
        [return: MarshalAsAttribute(UnmanagedType.Bool)]
        static extern bool CreateProcessW([InAttribute()] [MarshalAsAttribute(UnmanagedType.LPWStr)] string lpApplicationName, IntPtr lpCommandLine, [InAttribute()] IntPtr lpProcessAttributes, [InAttribute()] IntPtr lpThreadAttributes, [MarshalAsAttribute(UnmanagedType.Bool)] bool bInheritHandles, uint dwCreationFlags, [InAttribute()] IntPtr lpEnvironment, [InAttribute()] [MarshalAsAttribute(UnmanagedType.LPWStr)] string lpCurrentDirectory, [InAttribute()] ref STARTUPINFOW lpStartupInfo, [OutAttribute()] out PROCESS_INFORMATION lpProcessInformation);

        static bool CreateProcessW_Hooked([MarshalAsAttribute(UnmanagedType.LPWStr)] string lpApplicationName, IntPtr lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, [MarshalAsAttribute(UnmanagedType.Bool)] bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, [MarshalAsAttribute(UnmanagedType.LPWStr)] string lpCurrentDirectory, ref STARTUPINFOW lpStartupInfo, [OutAttribute()] out PROCESS_INFORMATION lpProcessInformation)
        {
            try
            {
                MalMonInject This = (MalMonInject)HookRuntimeInfo.Callback;

                lock (This.Queue)
                {
                    //Time + Pid + Tid + Api + Content
                    This.Queue.Push(ActivityMonitor.FormatMessage(DateTime.Now, "CreateProcessW", Marshal.PtrToStringUni(lpCommandLine));
                }
            }
            catch
            {
            }

            // call original API...
            return CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, ref lpStartupInfo, out lpProcessInformation);
        }
    }
}
